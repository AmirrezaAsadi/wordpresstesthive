<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Developer Network Hive Plot</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/papaparse@latest/papaparse.min.js"></script>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            font-family: Arial, sans-serif;
        }
        .container {
            max-width: 1200px;
            padding: 20px;
            text-align: center;
        }
        .notes {
            margin-top: 20px;
            text-align: left;
            font-size: 14px;
            color: #666;
        }
        svg {
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>
    <div class="container">
        <h2>Developer Network Hive Plot</h2>
        <svg id="hive-plot"></svg>
        <div class="notes">
            <p>• Axes represent Betweenness, In-Degree, and Out-Degree</p>
            <p>• Node position on each axis shows the metric value</p>
            <p>• Node color represents country</p>
            <p>• Edge thickness shows review frequency</p>
            <p>• Hover over nodes for detailed information</p>
        </div>
    </div>

    <script>
        async function loadAndDraw() {
            try {
                const [devResponse, edgeResponse] = await Promise.all([
                    fetch('./developer_network_countrybetweenness.csv'),
                    fetch('./network_edges.csv')
                ]);

                const [devText, edgeText] = await Promise.all([
                    devResponse.text(),
                    edgeResponse.text()
                ]);

                const developers = Papa.parse(devText, {
                    header: true,
                    dynamicTyping: true,
                    skipEmptyLines: true
                }).data;

                const edges = Papa.parse(edgeText, {
                    header: true,
                    dynamicTyping: true,
                    skipEmptyLines: true
                }).data;

                createHivePlot(developers, edges);
            } catch (error) {
                console.error('Error loading data:', error);
            }
        }

        function createHivePlot(developers, edges) {
            const width = 1000;
            const height = 1000;
            const radius = Math.min(width, height) / 2 - 100;

            const svg = d3.select('#hive-plot')
                .attr('width', width)
                .attr('height', height)
                .append('g')
                .attr('transform', `translate(${width/2},${height/2})`);

            const axes = [
                { name: 'Betweenness', angle: 0, property: 'betweenness' },
                { name: 'In-Degree', angle: 120, property: 'in_degree' },
                { name: 'Out-Degree', angle: 240, property: 'out_degree' }
            ];

            const scales = {
                betweenness: d3.scaleLinear()
                    .domain([0, d3.max(developers, d => d.betweenness) || 0])
                    .range([0, radius]),
                in_degree: d3.scaleLinear()
                    .domain([0, d3.max(developers, d => d.in_degree) || 0])
                    .range([0, radius]),
                out_degree: d3.scaleLinear()
                    .domain([0, d3.max(developers, d => d.out_degree) || 0])
                    .range([0, radius])
            };

            // Draw axes
            axes.forEach(axis => {
                const angle = (axis.angle - 90) * Math.PI / 180;
                const x2 = Math.cos(angle) * radius;
                const y2 = Math.sin(angle) * radius;

                svg.append('line')
                    .attr('x1', 0)
                    .attr('y1', 0)
                    .attr('x2', x2)
                    .attr('y2', y2)
                    .attr('stroke', '#999')
                    .attr('stroke-width', 2);

                svg.append('text')
                    .attr('x', Math.cos(angle) * (radius + 20))
                    .attr('y', Math.sin(angle) * (radius + 20))
                    .attr('text-anchor', 'middle')
                    .attr('dominant-baseline', 'middle')
                    .text(axis.name)
                    .attr('font-size', '14px')
                    .attr('font-weight', 'bold');
            });

            // Calculate node positions
            const nodePositions = new Map();
            developers.forEach(dev => {
                axes.forEach(axis => {
                    const value = dev[axis.property];
                    const distance = scales[axis.property](value);
                    const angle = (axis.angle - 90) * Math.PI / 180;
                    const x = Math.cos(angle) * distance;
                    const y = Math.sin(angle) * distance;

                    if (!nodePositions.has(dev.developer_id)) {
                        nodePositions.set(dev.developer_id, {});
                    }
                    nodePositions.get(dev.developer_id)[axis.property] = { x, y };
                });
            });

            // Draw edges
            edges.forEach(edge => {
                const sourcePos = nodePositions.get(edge.source);
                const targetPos = nodePositions.get(edge.target);

                if (sourcePos && targetPos) {
                    Object.entries(sourcePos).forEach(([sourceAxis, sourceCoord]) => {
                        Object.entries(targetPos).forEach(([targetAxis, targetCoord]) => {
                            if (sourceAxis !== targetAxis) {
                                svg.append('path')
                                    .attr('d', `M ${sourceCoord.x} ${sourceCoord.y} Q 0 0 ${targetCoord.x} ${targetCoord.y}`)
                                    .attr('fill', 'none')
                                    .attr('stroke', '#ccc')
                                    .attr('stroke-opacity', 0.2)
                                    .attr('stroke-width', Math.sqrt(edge.weight));
                            }
                        });
                    });
                }
            });

            // Draw nodes
            developers.forEach(dev => {
                const positions = nodePositions.get(dev.developer_id);
                Object.entries(positions).forEach(([axis, pos]) => {
                    svg.append('circle')
                        .attr('cx', pos.x)
                        .attr('cy', pos.y)
                        .attr('r', 4)
                        .attr('fill', getCountryColor(dev.country))
                        .attr('stroke', '#fff')
                        .attr('stroke-width', 1)
                        .append('title')
                        .text(`${dev.developer_id}\nCountry: ${dev.country}\nBetweenness: ${dev.betweenness.toFixed(4)}\nIn-degree: ${dev.in_degree}\nOut-degree: ${dev.out_degree}`);
                });
            });

            // Add legend
            const legend = svg.append('g')
                .attr('transform', `translate(${-width/2 + 20}, ${-height/2 + 20})`);

            legend.append('text')
                .attr('y', 0)
                .text('Node color represents country')
                .attr('font-size', '12px');

            legend.append('text')
                .attr('y', 20)
                .text('Edge thickness represents review frequency')
                .attr('font-size', '12px');
        }

        function getCountryColor(country) {
            const colorScale = d3.scaleOrdinal(d3.schemeCategory10);
            return colorScale(country);
        }

        // Start the visualization
        loadAndDraw();
    </script>
</body>
</html>
